<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		function Node(value) {
			this.value = value;
			this.neighbor = [];
		}
		var a = new Node('a');
		var b = new Node('b');
		var c = new Node('c');
		var d = new Node('d');
		var e = new Node('e');

		var pointSet = [];
		pointSet.push(a);
		pointSet.push(b);
		pointSet.push(c);
		pointSet.push(d);
		pointSet.push(e);

		var distance = [
			[0,        3,        5,        8,        Infinity],
			[3,        0,        Infinity, 4,        7       ],
			[5,        Infinity, 0,        6,        Infinity],
			[8,        4,        6,        0,        Infinity],
			[Infinity, 7,        Infinity, Infinity, 0       ]
		];

		function search(pointset,distance,start,pointConnet) {
			var len = pointset.length; //起点到其他点的距离的距离数/点的个数
			var min = Infinity;  //最短距离
			pointConnet.push(start);
			//所有点都已连接，则return
			if(len == pointConnet.length) return;
			//找到最短距离
			for(var i = 0;i < pointConnet.length;i ++){  //遍历已连接的各点
				var pointIndex = pointset.indexOf(pointConnet[i]);  //点在pointset中的索引
				// console.log(pointIndex);
				for(var j = 0;j < len;j ++){  //遍历点的各边
					if(distance[pointIndex][j] < min && pointConnet.indexOf(pointSet[j]) == -1){ 
						min = distance[pointIndex][j]; //起点到第j个点的距离最短

						var startIndex = pointIndex;  //具有最短距离的起点索引
						var end = pointSet[j];        //具有最短距离的终点
						var endIndex = j;             //具有最短距离的终点索引
					}
				}
			}
			// console.log('end:',end); //每次新连接进去的点
			//将以找到的最短距离置为infinity，方便后续查找时跳过
			distance[startIndex][endIndex] = Infinity; 
			distance[endIndex][startIndex] = Infinity;
			//连接两点
			pointset[startIndex].neighbor.push(end);
			end.neighbor.push(pointset[startIndex]);

			search(pointSet,distance,end,pointConnet);
		}

		function Prim(pointset,distance,start) {
			var pointConnet = []; //已连接的点集
			search(pointset,distance,start,pointConnet);
			return start;
		}

		console.log(Prim(pointSet,distance,b));

	</script>
</body>
</html>