<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		function Node(value) {
			this.value = value;
			this.neighbor = [];
		}
		var a = new Node('a');
		var b = new Node('b');
		var c = new Node('c');
		var d = new Node('d');
		var e = new Node('e');
		var f = new Node('f');

		var pointSet = [];
		pointSet.push(a);
		pointSet.push(b);
		pointSet.push(c);
		pointSet.push(d);
		pointSet.push(e);
		pointSet.push(f);

		var distance = [
			[0,        3,        5,        8,        Infinity,Infinity],
			[3,        0,        Infinity, 4,        7       ,Infinity],
			[5,        Infinity, 0,        6,        Infinity,Infinity],
			[8,        4,        6,        0,        Infinity,2       ],
			[Infinity, 7,        Infinity, Infinity, 0       ,Infinity],
			[Infinity, Infinity, Infinity, 2       , Infinity,Infinity]
		];
	     //连接两点
		function connect(point1,point2){
			point1.neighbor.push(point2);
			point2.neighbor.push(point1);
		}

		function search(pointSet,distance,pointConnet) {
			var min = Infinity;
			var Len = pointSet.length;
			//获取到最短距离的两个端点的索引，对称，所以只循环比较一半
			for(var i = 0;i< Len;i ++){
				for(var j = 0;j < i;j ++){
					if( distance[i][j] < min ){
						min = distance[i][j];
						var minStart = i;    
						var minEnd = j;
					}
				}
			}
			distance[minStart][minEnd] = Infinity; 

			var index1 = -1,  //点所在部落的索引
				index2 = -1,
				seperatePoint = null; //不在任何部落的点
			//获取点在部落的索引index1，index2
			for(var i = 0;i < pointConnet.length;i ++){
				if(pointConnet[i].indexOf(pointSet[minEnd]) != -1){
					var index1 = i;
				}else {
					seperatePoint = pointSet[minEnd]; 
				}
				if(pointConnet[i].indexOf(pointSet[minStart]) != -1){
					var index2 = i;
				}else {
					seperatePoint = pointSet[minStart]; 
				}
			}
			// console.log(index1,index2);

			//判断最短距离的两点是否可连接
			//可连接的情况：
			//1.两点都不在部落中-->两点形成一个部落
			//2.两点中有一个不在部落中-->加进另一个点部落中
			//3.两点在不同的部落中-->两个部落形成一个部落

			//不可连接：
			//4.两点在一个部落中（形成回路）
			if(index1 == -1 && index2 == -1){ //1
				pointConnet.push([pointSet[minEnd], pointSet[minStart]]);
				connect(pointSet[minStart],pointSet[minEnd]);

			}else if((index1 != -1 && index2 == -1) || (index2 != -1 && index1 == -1)){ //2
				var i = index1 == -1 ? index2 : index1;
				pointConnet[i].push(seperatePoint);
				connect(pointSet[minStart],pointSet[minEnd]);

			}else if(index1 != index2 && index1 != -1 && index2 != -1){ //3
				//concat不改变原数组，返回的结果要重新赋值给pointConnet[index1]
				pointConnet[index1] = pointConnet[index1].concat(pointConnet[index2]);
				pointConnet.splice(index2,1);
				connect(pointSet[minStart],pointSet[minEnd]);

			}

			if(pointSet.length == pointConnet[0].length) return;

			search(pointSet,distance,pointConnet);
		}

		function Cruskal(pointSet,distance) {
			var pointConnet = []; //已连接的点部落
			search(pointSet,distance,pointConnet);
			return pointSet[0];
		}
		console.log(Cruskal(pointSet,distance));

	</script>
</body>
</html>